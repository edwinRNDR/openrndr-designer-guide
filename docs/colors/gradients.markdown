---
# File generated by dokgen. Do not edit. 
# Edit 'src/main/kotlin/docs/20_Colors/C300_Gradients.kt' instead.
layout: default
title: Gradients
parent: Colors
last_modified_at: 2025.10.30 07:02:05 +0000
nav_order: 300
has_children: false
---
 
# Gradients in OPENRNDR

In OPENRNDR gradients are implemented using shade styles. The [orx-shade-styles](https://github.com/openrndr/orx/tree/master/orx-shade-styles)) 
library implements a wide variety of gradients. 
 
## Introduction to gradients

A simple linear gradient can be created by setting the gradient type to `linear` in the gradient builder. 
The colors of the gradient are specified using `stops`. Here we set `stops[0.0]` to `ColorRGBa.BLACK` and `stops[1.0]` 
to `ColorRGBa.RED` to create a black to red gradient. 
 
 
<img alt="../media/gradients-001.png" src="../media/gradients-001.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.BLACK
                stops[1.0] = ColorRGBa.RED
                
                linear {
                    start = Vector2(0.25, 0.25)
                    end = Vector2(0.75, 0.75)
                }
            }
            drawer.circle(drawer.bounds.center, 200.0)
        }
    }
}
``` 
 
More colors can be added to the gradient by adding more `stops`. Here we add an additional color at `0.5` using `ColorRGBa.WHITE`.
The resulting gradient is a mix of black, white and red.             
 
<img alt="../media/gradients-001-b.png" src="../media/gradients-001-b.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.BLACK
                stops[0.5] = ColorRGBa.WHITE
                stops[1.0] = ColorRGBa.RED
                
                linear {
                    start = Vector2(0.25, 0.25)
                    end = Vector2(0.75, 0.75)
                }
            }
            drawer.circle(drawer.bounds.center, 200.0)
        }
    }
}
``` 
 
## Gradient units
Let's have a look at the gradient units. By default the gradients are defined in relative coordinates, 
these coordinates are relative to the bounds of the shapes drawn. This is best demonstrated by drawing multiple
shapes.

In the image below we draw a grid of circles. Each circle has the gradient applied relative to its own bounds.
             
 
<img alt="../media/gradients-001-c.png" src="../media/gradients-001-c.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.WHITE
                stops[1.0] = ColorRGBa.BLACK
                
                linear {
                    start = Vector2(0.25, 0.25)
                    end = Vector2(0.75, 0.75)
                }
            }
            val grid = drawer.bounds.grid(3, 3)
            for (cell in grid.flatten()) {
                drawer.circle(cell.center, cell.width * 0.45)
            }
        }
    }
}
``` 
 
Alternatively we can can configure the gradient to be defined in world space units. We now
define the `start` and `end` points relative to the world space (which coincides with the view space when the view is not adjusted). 
 
<img alt="../media/gradients-001-d.png" src="../media/gradients-001-d.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.WHITE
                stops[1.0] = ColorRGBa.BLACK
                
                fillUnits = FillUnits.WORLD
                
                linear {
                    start = drawer.bounds.position(0.25, 0.25)
                    end = drawer.bounds.position(0.75, 0.75)
                }
            }
            val grid = drawer.bounds.grid(3, 3)
            for (cell in grid.flatten()) {
                drawer.circle(cell.center, cell.width * 0.45)
            }
        }
    }
}
``` 
 
## Gradient types

### Linear gradients    

Linear gradients are created by setting the gradient type to `linear` in the gradient builder. Linear gradients have two
properties that can be configured: `start` and `end`. These properties are vectors that define the start and end points
of the gradient line. For the following image we show a grid of linear gradients with varying orientations. 
 
<img alt="../media/gradients-001-e.png" src="../media/gradients-001-e.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(3, 3).flatten()
            
            for ((index, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.WHITE
                    stops[1.0] = ColorRGBa.BLACK
                    
                    linear {
                        start = Vector2(0.25, 0.25).rotate(360.0 * index / (grid.size.toDouble()), Vector2(0.5, 0.5))
                        end = Vector2(0.75, 0.75).rotate(360.0 * index / (grid.size.toDouble()), Vector2(0.5, 0.5))
                    }
                }
                drawer.rectangle(cell.offsetEdges(-20.0))
            }
        }
    }
}
``` 
 
In the next image vary the distance between the start and end points.          
 
<img alt="../media/gradients-001-f.png" src="../media/gradients-001-f.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(3, 3).flatten()
            
            for ((index, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.PINK
                    stops[1.0] = ColorRGBa.WHITE
                    
                    linear {
                        start = Vector2(0.0, 0.5 * index / 9.0)
                        end = Vector2(0.0, 1.0 - 0.5 * index / 9.0)
                    }
                }
                drawer.rectangle(cell.offsetEdges(-20.0))
            }
        }
    }
}
``` 
 
### Radial gradients        

Radial gradients are created by setting the gradient type to `radial` in the gradient builder.
Radial gradients have two properties that can be configured: `radius` and `center`. 
 
<img alt="../media/gradients-002.png" src="../media/gradients-002.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.PINK
                stops[1.0] = ColorRGBa.BLUE
                
                radial {
                    radius = 0.5
                    center = Vector2(0.5, 0.5)
                }
            }
            drawer.rectangle(drawer.bounds.offsetEdges(-100.0))
        }
    }
}
``` 
 
In the next image we vary the center of the radial gradient. 
 
<img alt="../media/gradients-002-a.png" src="../media/gradients-002-a.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(5, 5, 10.0, 10.0, 10.0, 10.0)
            
            for ((y, row) in grid.withIndex()) {
                for ((x, cell) in row.withIndex()) {
                    drawer.shadeStyle = gradient<ColorRGBa> {
                        stops[0.0] = ColorRGBa.PINK
                        stops[1.0] = ColorRGBa.BLUE
                        
                        radial {
                            radius = 0.5
                            center = Vector2(x / 4.0, y / 4.0)
                        }
                    }
                    drawer.rectangle(cell)
                }
            }
        }
    }
}
``` 
 
Here are the results of varying the `radius` of the radial gradient. 
 
<img alt="../media/gradients-002-b.png" src="../media/gradients-002-b.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(5, 5, 10.0, 10.0, 10.0, 10.0).flatten()
            
            for ((index, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.PINK
                    stops[1.0] = ColorRGBa.BLUE
                    
                    radial {
                        radius = index / 24.0
                    }
                }
                drawer.rectangle(cell)
            }
        }
    }
}
``` 
 
### Conic gradients

Conic gradients are created by setting the gradient type to `conic` in the gradient builder. Conic
gradients have three properties that can be configured: `center`, `rotation` and `angle`. 
 
<img alt="../media/gradients-002-c.png" src="../media/gradients-002-c.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(1, 1, 10.0, 10.0, 10.0, 10.0).flatten()
            
            for ((index, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.ORANGE_RED
                    stops[0.5] = ColorRGBa.BLUE_STEEL
                    stops[1.0] = ColorRGBa.OLIVE
                    
                    conic {
                        angle = 360.0
                        center = Vector2(0.5, 0.5)
                    }
                }
                drawer.rectangle(cell)
            }
        }
    }
}
``` 
 
Let's vary the `rotation` of the conic gradient. 
 
<img alt="../media/gradients-002-d.png" src="../media/gradients-002-d.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(5, 5, 10.0, 10.0, 10.0, 10.0).flatten()
            
            for ((index, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.ORANGE_RED
                    stops[0.5] = ColorRGBa.BLUE_STEEL
                    stops[1.0] = ColorRGBa.OLIVE
                    
                    conic {
                        rotation = 360.0 * index / 25.00
                    }
                }
                drawer.rectangle(cell)
            }
        }
    }
}
``` 
 
Let's vary the `angle` of the conic gradient. 
 
<img alt="../media/gradients-002-e.png" src="../media/gradients-002-e.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(5, 5, 10.0, 10.0, 10.0, 10.0).flatten()
            
            for ((index, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.ORANGE_RED
                    stops[0.5] = ColorRGBa.BLUE_STEEL
                    stops[1.0] = ColorRGBa.OLIVE
                    
                    conic {
                        angle = (index + 1.0) * 360.0 / 25.0
                    }
                }
                drawer.rectangle(cell)
            }
        }
    }
}
``` 
 
And finally let's vary the `center` of the conic gradient. 
 
<img alt="../media/gradients-002-f.png" src="../media/gradients-002-f.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(5, 5, 10.0, 10.0, 10.0, 10.0)
            
            for ((y, row) in grid.withIndex()) {
                for ((x, cell) in row.withIndex()) {
                    drawer.shadeStyle = gradient<ColorRGBa> {
                        stops[0.0] = ColorRGBa.ORANGE_RED
                        stops[0.5] = ColorRGBa.BLUE_STEEL
                        stops[1.0] = ColorRGBa.OLIVE
                        
                        conic {
                            center = Vector2(x / 4.0, y / 4.0)
                        }
                    }
                    drawer.rectangle(cell)
                }
            }
        }
    }
}
``` 
 
### Stellar gradients
    
    Stellar gradients are star shaped gradients, they can be used by setting the gradient type to `stellar`. Stellar gradients
    have `rotation`, `center`, `sharpness`, `sides` and `radius` properties.                 
         
 
<img alt="../media/gradients-002-g.png" src="../media/gradients-002-g.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(1, 1, 10.0, 10.0, 10.0, 10.0)
            
            for ((y, row) in grid.withIndex()) {
                for ((x, cell) in row.withIndex()) {
                    drawer.shadeStyle = gradient<ColorRGBa> {
                        stops[0.0] = ColorRGBa.PEACH_PUFF
                        stops[0.5] = ColorRGBa.LIGHT_SKY_BLUE.opacify(0.5)
                        stops[1.0] = ColorRGBa.BLACK
                        
                        stellar {
                            radius = 0.25
                        }
                    }
                    drawer.rectangle(cell)
                }
            }
        }
    }
}
``` 
 
Let's vary the `sides` horizontally and `sharpness` vertically of the stellar gradient. 
 
<img alt="../media/gradients-002-h.png" src="../media/gradients-002-h.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(7, 7, 10.0, 10.0, 10.0, 10.0)
            
            for ((y, row) in grid.withIndex()) {
                for ((x, cell) in row.withIndex()) {
                    drawer.shadeStyle = gradient<ColorRGBa> {
                        stops[0.0] = ColorRGBa.PEACH_PUFF
                        stops[0.5] = ColorRGBa.LIGHT_SKY_BLUE.opacify(0.5)
                        stops[1.0] = ColorRGBa.BLACK
                        
                        stellar {
                            sides = 3 + x
                            sharpness = y / 6.0
                        }
                    }
                    drawer.rectangle(cell)
                }
            }
        }
    }
}
``` 
 
### Elliptical gradients

Elliptical gradients are created by setting the gradient type to `elliptic` in the gradient builder. Elliptical gradients
have `rotation`, `center`, `radiusX` and `radiusY` properties. 
 
<img alt="../media/gradients-002-i.png" src="../media/gradients-002-i.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(1, 1, 10.0, 10.0, 10.0, 10.0)
            
            for ((y, row) in grid.withIndex()) {
                for ((x, cell) in row.withIndex()) {
                    drawer.shadeStyle = gradient<ColorRGBa> {
                        stops[0.0] = ColorRGBa.CRIMSON
                        stops[0.5] = ColorRGBa.DODGER_BLUE
                        stops[1.0] = ColorRGBa.LIME_GREEN
                        
                        elliptic {
                            radiusX = 0.25
                            radiusY = 0.5
                        }
                    }
                    drawer.rectangle(cell)
                }
            }
        }
    }
}
``` 
 
Let's vary the `radiusX`, `radiusY` and `rotation` of the elliptical gradient.` 
 
<img alt="../media/gradients-002-j.png" src="../media/gradients-002-j.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(13, 13)
            drawer.stroke = null
            
            for ((y, row) in grid.withIndex()) {
                for ((x, cell) in row.withIndex()) {
                    drawer.shadeStyle = gradient<ColorRGBa> {
                        stops[0.0] = ColorRGBa.CRIMSON
                        stops[0.5] = ColorRGBa.DODGER_BLUE
                        stops[1.0] = ColorRGBa.LIME_GREEN
                        
                        spreadMethod = SpreadMethod.REPEAT
                        elliptic {
                            val v = Vector2(x - 6.0, y - 6.0)
                            rotation = atan2(y - 6.0, x - 6.0).asDegrees + 180.0
                            radiusX = 1.0
                            radiusY = 1.0 / (1.0 + v.length * 0.25)
                        }
                    }
                    drawer.rectangle(cell)
                }
            }
        }
    }
}
``` 
 
## Gradient spread method

The spread method controls how the gradient is distributed across the area it covers. The available options are:
`PAD`, `REFLECT`, `REPEAT`. The default is `PAD`.

In the image below we show all three methods side by side. 
 
<img alt="../media/gradients-002-k.png" src="../media/gradients-002-k.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(3, 1, 10.0, 10.0, 10.0, 10.0).flatten()
            drawer.stroke = null
            
            for ((x, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.CORAL
                    stops[0.5] = ColorRGBa.SKY_BLUE
                    stops[1.0] = ColorRGBa.DARK_OLIVE_GREEN
                    
                    spreadMethod = when(x) {
                        0 -> SpreadMethod.PAD
                        1 -> SpreadMethod.REFLECT
                        2 -> SpreadMethod.REPEAT
                        else -> error("nothing else")
                    }
                    linear {
                        start = Vector2(0.5, 1.0 / 3.0)
                        end = Vector2(0.5, 2.0 / 3.0)
                    }
                }
                drawer.rectangle(cell)
            }
        }
    }
}
``` 
 
## Gradient quantization
    

We can quantize the output levels of the gradient by setting `quantization` to the desired number of
quantization levels. The default is `0`. 
 
<img alt="../media/gradients-002-l.png" src="../media/gradients-002-l.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val grid = drawer.bounds.grid(15, 1, 10.0, 10.0, 0.0, 0.0).flatten()
            drawer.stroke = null
            for ((x, cell) in grid.withIndex()) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    fillUnits = FillUnits.WORLD
                    stops[0.0] = ColorRGBa.PINK
                    stops[0.5] = ColorRGBa.DARK_CYAN
                    stops[1.0] = ColorRGBa.DARK_SEA_GREEN
                    quantization = 2 + x
                    linear {
                        start = drawer.bounds.position(0.5, 0.0)
                        end = drawer.bounds.position(0.5, 1.0)
                    }
                }
                drawer.rectangle(cell)
            }
        }
    }
}
``` 
 
## Designing with gradients

### Gradients and typography

Here are some tips and examples for designing with type and gradients.

### Demonstration 1  

This title screen is designed with a linear gradient in the background. The type is drawn 
with an elliptic gradient. 
 
<img alt="../media/gradients-003-a.png" src="../media/gradients-003-a.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
        
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.BLACK
                stops[0.5] = ColorRGBa.BLUE
                stops[1.0] = ColorRGBa.BLACK
                linear {
                }
                quantization = 16
            }
            drawer.rectangle(drawer.bounds.offsetEdges(-10.0))
            
            drawer.shadeStyle = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.PINK
                stops[1.0] = ColorRGBa.BLUE.opacify(0.0)
                
                fillFit = FillFit.CONTAIN
                elliptic {
                    radiusY = 0.75
                    radiusX = 0.5
                    rotation = 45.0
                }
                quantization = 8
            }
            
            drawer.fontMap = loadFont("data/fonts/default.otf", 128.0)
            writer {
                box = drawer.bounds
                horizontalAlign = 0.5
                verticalAlign = 0.5
                text("IN A LAND BEFORE TIME")
            }
        }
    }
}
``` 
 
### Demonstration 2

This title screen is designed with a linear rainbow gradient in the background. The type is drawn
with a similar but more vibrant gradient with quantization set to 32. 
 
<img alt="../media/gradients-003-b.png" src="../media/gradients-003-b.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                (0..10).forEach {
                    stops[it / 10.0] = ColorRGBa.RED.saturate<OKHSV>(0.30).shiftHue<OKHSV>(it * 36.0)
                }
                fillUnits = FillUnits.WORLD
                linear {
                    start = drawer.bounds.position(0.5, 0.0)
                    end = drawer.bounds.position(0.5, 1.0)
                }
            }
            drawer.rectangle(drawer.bounds.offsetEdges(-10.0))
            
            drawer.shadeStyle = gradient<ColorRGBa> {
                (0..10).forEach {
                    stops[it / 10.0] = ColorRGBa.RED.saturate<OKHSV>(1.0).shiftHue<OKHSV>(it * 36.0)
                }
                fillUnits = FillUnits.WORLD
                linear {
                    start = drawer.bounds.position(0.5, 0.0)
                    end = drawer.bounds.position(0.5, 1.0)
                }
                quantization = 32
            }
            
            drawer.fontMap = loadFont("data/fonts/default.otf", 128.0)
            writer {
                box = drawer.bounds
                horizontalAlign = 0.5
                verticalAlign = 0.5
                text("RETURN TO A LAND BEFORE TIME")
            }
        }
    }
}
``` 
 
### Demonstration 3

This title screen is designed with a 4 sided stellar gradient in the background. The type is drawn
with a similar gradient but with the color slightly offset. 
 
<img alt="../media/gradients-003-c.png" src="../media/gradients-003-c.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.shadeStyle = gradient<ColorRGBa> {
                (0..10).forEach {
                    stops[it / 10.0] = ColorRGBa.RED.saturate<OKHSV>(0.30).shiftHue<OKHSV>(it * 36.0)
                    stops[(it + 0.5) / 10.0] = ColorRGBa.BLACK
                }
                fillUnits = FillUnits.WORLD
                spreadMethod = SpreadMethod.REPEAT
                quantization = 19
                stellar {
                    center = drawer.bounds.position(0.5, 0.25)
                    radius = drawer.bounds.width / 2.0
                    rotation = 45.0
                    sides = 4
                    sharpness = 0.0
                }
            }
            drawer.rectangle(drawer.bounds.offsetEdges(-10.0))
            
            drawer.shadeStyle = gradient<ColorRGBa> {
                (0..10).forEach {
                    stops[it / 10.0] = ColorRGBa.RED.saturate<OKHSV>(0.30).shiftHue<OKHSV>((it + 1) * 36.0)
                    stops[(it + 0.5) / 10.0] = ColorRGBa.BLACK
                }
                fillUnits = FillUnits.WORLD
                spreadMethod = SpreadMethod.REPEAT
                quantization = 19 * 4
                stellar {
                    center = drawer.bounds.position(0.5, 0.25)
                    radius = drawer.bounds.width / 2.0
                    rotation = 45.0
                    sides = 4
                    sharpness = 0.0
                }
            }
            
            drawer.fontMap = loadFont("data/fonts/default.otf", 164.0)
            writer {
                box = drawer.bounds.offsetEdges(-20.0)
                horizontalAlign = 0.5
                verticalAlign = 1.0
                text("SON OF THE LAND BEFORE TIME")
            }
        }
    }
}
``` 
 
### Demonstration 4

This title screen is made by drawing the text a 100 times. Each copy has a slightly different gradient,
each copy uses different text alignment configuration. 
 
<img alt="../media/gradients-003-d.png" src="../media/gradients-003-d.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            for (i in 0 until 100) {
                drawer.fill = ColorRGBa.WHITE.shade(i / 99.0)
                drawer.shadeStyle = gradient<ColorRGBa> {
                    (0..10).forEach {
                        stops[it / 10.0] = ColorRGBa.RED.saturate<OKHSV>(0.0).shiftHue<OKHSV>(it * 36.0)
                        stops[(it + 0.9) / 10.0] = ColorRGBa.BLACK.opacify(0.0)
                    }
                    fillUnits = FillUnits.WORLD
                    spreadMethod = SpreadMethod.REPEAT
                    //quantization = 19
                    stellar {
                        center = drawer.bounds.position(i / 99.0, i / 99.0)
                        radius = drawer.bounds.width / 8.0
                        rotation = 45.0
                        sides = 8
                        sharpness = 0.5
                    }
                }
                
                drawer.fontMap = loadFont("data/fonts/default.otf", 164.0)
                writer {
                    box = drawer.bounds.offsetEdges(-20.0)
                    horizontalAlign = i / 99.0
                    verticalAlign = i / 99.0
                    text("BEFORE THE LAND BEFORE TIME")
                }
            }
        }
    }
}
``` 
 
### Demonstration 5

    This title screen is made by drawing the text a 100 times. Each copy has a slightly different gradient,
    each copy uses different text alignment configuration. 
 
<img alt="../media/gradients-003-e.png" src="../media/gradients-003-e.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val gs = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.LIGHT_CORAL
                stops[0.5] = ColorRGBa.ORANGE
                stops[1.0] = ColorRGBa.OLIVE
                
                fillUnits = FillUnits.WORLD
                spreadMethod = SpreadMethod.REPEAT
                radial {
                    radius = drawer.bounds.width / 8.0
                }
            }
            drawer.shadeStyle = gs
            drawer.stroke = null
            drawer.rectangle(drawer.bounds)
            
            drawer.shadeStyle = null
            drawer.fill = ColorRGBa.WHITE.opacify(0.9)
            drawer.rectangle(drawer.bounds.offsetEdges(-10.0))
            
            drawer.fill = ColorRGBa.WHITE
            drawer.fontMap = loadFont("data/fonts/default.otf", 164.0)
            drawer.shadeStyle = gs
            writer {
                horizontalAlign = 0.5
                verticalAlign = 0.5
                box = drawer.bounds.offsetEdges(-20.0)
                leading = -50.0
                tracking = 10.0
                text("RETURN OF THE SON OF THE LAND BEFORE TIME")
            }
        }
    }
}
``` 
 
### Demonstration 6

    This title screen is made by drawing the text a 100 times. Each copy has a slightly different gradient,
    each copy uses different text alignment configuration. 
 
<img alt="../media/gradients-003-f.png" src="../media/gradients-003-f.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            val gs = gradient<ColorRGBa> {
                stops[0.0] = ColorRGBa.LIGHT_CORAL
                stops[0.49] = ColorRGBa.LIGHT_CORAL.opacify(0.0)
                stops[0.5] = ColorRGBa.ORANGE
                stops[1.0] = ColorRGBa.OLIVE
                
                fillUnits = FillUnits.WORLD
                spreadMethod = SpreadMethod.REPEAT
                radial {
                    radius = drawer.bounds.width / 32.0
                    center = drawer.bounds.center
                }
            }
            drawer.shadeStyle = gs
            
            for (i in 1 until 12) {
                val scale = 1.2.pow(-i.toDouble())
                drawer.fontMap = loadFont("data/fonts/default.otf", 92.0 * scale)
                
                val contour = Circle(drawer.bounds.center, 360.0 * scale).contour.transform(buildTransform {
                    translate(drawer.bounds.center)
                    rotate(i * 360.0 / 12.0)
                    translate(-drawer.bounds.center)
                }).rectified()
                drawer.textOnContour("THE RETURN OF THE SON TO BEFORE THE LAND BEFORE TIME.", contour)
            }
        }
    }
}
``` 
 
<img alt="../media/gradients-003.png" src="../media/gradients-003.png" loading="lazy"> 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.stroke = null
            for (i in 9 downTo 0) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.PINK
                    stops[1.0] = ColorRGBa.MAGENTA
                    
                    linear {
                        start = Vector2(0.5, 0.0).rotate(i * 36.0, Vector2(0.5, 0.5))
                        end = Vector2(0.5, 1.0).rotate(i * 36.0, Vector2(0.5, 0.5))
                    }
                }
                drawer.circle(drawer.bounds.center, 200.0 + i * 15.0)
            }
        }
    }
}
``` 
 
## Linear gradients with animated rotation

Simply by including a `seconds` value in the gradient builder the gradient will rotate over time.
 
 
<video controls preload="none" loop poster="../media/gradients-004-thumb.jpg">
    <source src="../media/gradients-004.mp4" type="video/mp4">
</video>
 
 
```kotlin
import org.openrndr.application
import org.openrndr.color.ColorRGBa
import org.openrndr.draw.loadFont
import org.openrndr.extra.color.presets.*
import org.openrndr.extra.color.spaces.OKHSV
import org.openrndr.extra.color.tools.saturate
import org.openrndr.extra.color.tools.shiftHue
import org.openrndr.extra.shadestyles.fills.FillFit
import org.openrndr.extra.shadestyles.fills.FillUnits
import org.openrndr.extra.shadestyles.fills.SpreadMethod
import org.openrndr.extra.shadestyles.fills.gradients.gradient
import org.openrndr.extra.shapes.primitives.contour
import org.openrndr.extra.shapes.primitives.grid
import org.openrndr.extra.shapes.rectify.rectified
import org.openrndr.extra.textoncontour.textOnContour
import org.openrndr.extra.textwriter.writer
import org.openrndr.math.Vector2
import org.openrndr.math.asDegrees
import org.openrndr.math.transforms.buildTransform
import org.openrndr.shape.Circle
import kotlin.math.atan2
import kotlin.math.pow

fun main() = application {
    configure {
        width = 720
        height = 720
    }
    program {
        extend {
            drawer.stroke = null
            for (i in 9 downTo 0) {
                drawer.shadeStyle = gradient<ColorRGBa> {
                    stops[0.0] = ColorRGBa.PINK
                    stops[1.0] = ColorRGBa.MAGENTA
                    
                    linear {
                        start = Vector2(0.5, 0.0).rotate(seconds * 36.0 + i * 36.0, Vector2(0.5, 0.5))
                        end = Vector2(0.5, 1.0).rotate(seconds * 36.0 + i * 36.0, Vector2(0.5, 0.5))
                    }
                }
                drawer.circle(drawer.bounds.center, 200.0 + i * 15.0)
            }
        }
    }
}
``` 

[edit on GitHub](https://github.com/openrndr/openrndr-guide/blob/main/src/main/kotlin/docs/20_Colors/C300_Gradients.kt){: .btn .btn-github }